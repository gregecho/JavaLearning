## 正文 ##
### 1. 类访问权限 ###
>+ **每个编译单元（文件）都只能有一个public类**。每个编译单元有一个公共接口的概念是由那个公共类表达出来的。根据自己的需要，它可拥有任意多个提供支撑的“友好”类。但若在一个编译单元里使用了多个public类，编译器就会向我们提示一条出错消息。
>+ **public类的名字必须与包含了编译单元的那个文件的名字完全相符**，甚至包括它的大小写形式。所以对于Widget来说，文件的名字必须是Widget.java，而不应是widget.java或者WIDGET.java。同样地，如果出现不符，就会报告一个编译期错误。
>+ 可能（但并常见）有一个编译单元根本没有任何公共类。此时，可按自己的意愿任意指定文件名.

### 2. final关键字 ###
final关键字有如下使用情况：数据/方法和类。
#### 2.1  final数据 ####
>+ **final数据** 一个既是static又是final的域只占据一段不能被改变的存储空间。
>+ 对于基本类型，final使数值恒定不变；而对于对象引用，final使引用恒定不变。一旦一个引用被初始化指向一个对象，就无法把他改变指向另一个对象。
>+ 根据惯例即使static又是final的域使用大写表示。

#### 2.2  final参数 ####
>+ Java允许在参数列表中以声明的方式将参数指定为final，这意味着无法在方法中改变参数引用所指向的对象。
```java
public class FinalArguments{
  void with(final Gizmo g){
    // illegal -- g is final
    g = new Gizmo();
  }
  void without(Gizmo g){
    g = new Gizmo();//work, g is not final
    g.spin();
  }
}
```

#### 2.3  final方法 ####
Java中使用final类型的方法有以下两种原因：
>+ 设计原因：final类型的方法不允许其子类修改方法，也不允许子类覆盖父类的final方法。
>+ 效率原因：在早期的java实现中，如果方法被声明为final，编译器将final方法调用编译为内联调用。
新版的使用hotspot技术的java虚拟机可以探测方法调用情况而做效率优化，**final方法不再作为提高效率的手段，唯一的作用是确保方法不被子类覆盖**。

**注意**：任何private的方法都是隐式的final类型，同final方法类似，private方法不能被子类所覆盖，但是private比final更严格，基类的private方法对子类不可见，private方法不再是接口的一部分。

#### 2.4  final类 ####
当将某个类定义为final时，说明你不打算继承这个类，而且别人也无法这么做。

### 3.多态 ###
面向对象编程中的多态和继承往往是一起发挥作用的，使用继承，所有的子类和父类使用相同的对外接口，而多态的基础是**晚绑定或动态绑定或运行时绑定**，即对象引用使用基类类型，在编译时编译器无法确切知道到底调用哪一个具体类，**只有在运行时，java虚拟机才通过类型检查确定调用对象的具体类型**。

Java中默认对象引用全部是晚绑定，只有static和final类型的引用时早绑定或编译时绑定。

**注意**：只有正常的方法可以使用多态，字段和静态方法没有多态机制。构造方法也不支持多态机制，构造方法是隐式的static声明。

------------
Todo:
* [ ] 详解java继承/多态/封装
